#define configUSE_PREEMPTION            1
#define configUSE_IDLE_HOOK             0
#define configUSE_TICK_HOOK             0
#define configCPU_CLOCK_HZ              (50000000UL)
#define configTICK_RATE_HZ              ((TickType_t)1000)
#define configMAX_PRIORITIES            (5)
#define configMINIMAL_STACK_SIZE        (128)
#define configTOTAL_HEAP_SIZE           ((size_t)(10 * 1024))
#define configUSE_16_BIT_TICKS          0
#define configUSE_MUTEXES               1
#define configCHECK_FOR_STACK_OVERFLOW  2
#define configSUPPORT_DYNAMIC_ALLOCATION 1

#define configKERNEL_INTERRUPT_PRIORITY         (1)
#define configMAX_SYSCALL_INTERRUPT_PRIORITY    (1)

#define INCLUDE_vTaskDelay             1
#define INCLUDE_xTaskCreate            1
#define INCLUDE_xQueueCreate           1
#define INCLUDE_xQueueSend             1
#define INCLUDE_xQueueReceive          1

#include <stdio.h>
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
//#include "mult_control_reg.h" PRUEBAS
#include "csr.h"
#include "gr_heep.h"
#include "hart.h" // for wait_for_interrupt()
#include "rv_plic.h"

QueueHandle_t xQueue;

// Hooks vacíos requeridos por configuración FreeRTOS
void vApplicationTickHook(void) {}
void vApplicationIdleHook(void) {}
void vApplicationMallocFailedHook(void) { for(;;); }
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName) {
    (void)xTask; (void)pcTaskName; for(;;);
}

// Heap dinámico
uint8_t ucHeap[configTOTAL_HEAP_SIZE];

static inline uint32_t multiply_ab(uint32_t a, uint32_t b) {
    uint32_t result;
    asm volatile (
        ".insn r 0x2B, 0x7, 0x02, %0, %1, %2"  // Custom encoding for BITREV
        : "=r"(result) // Output operand (rd)
        : "r"(a),     // Input operand (rs1)
          "r"(b)     // Input operand (rs1)
    );
    return result;
}

void vSenderTask(void *pvParameters) {
    int valueToSend = 100;
    for (;;) {
        xQueueSend(xQueue, &valueToSend, portMAX_DELAY);
        vTaskDelay(pdMS_TO_TICKS(1000));  // cada 1 segundo
    }
}

void vReceiverTask(void *pvParameters) {
    int receivedValue;
    for (;;) {
        if (xQueueReceive(xQueue, &receivedValue, portMAX_DELAY) == pdPASS) {
            volatile uint8_t a = 2;
	    volatile uint8_t b = 3;
	    volatile uint16_t result;

	    result = multiply_ab(a, b);
	    printf("Result: %d\n", result);
        }
    }
}


int main(void) {
    xQueue = xQueueCreate(5, sizeof(int));

    if (xQueue == NULL) {
        printf("Error creando la cola.\n");
        while (1);
    }

    xTaskCreate(vSenderTask, "Sender", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
    xTaskCreate(vReceiverTask, "Receiver", configMINIMAL_STACK_SIZE, NULL, 1, NULL);

    vTaskStartScheduler();

    for (;;);  // no debe llegar aquí
}

